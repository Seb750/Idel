<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Mini MesTransmissions - Seb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    :root {
      --bg: #050816;
      --bg-card: #0f172a;
      --bg-card-soft: #111827;
      --accent: #3b82f6;
      --accent-soft: rgba(59,130,246,0.15);
      --accent-strong: #2563eb;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --danger: #f97373;
      --success: #22c55e;
      --border: #1f2937;
    }

    body.light {
      --bg: #f4f4f5;
      --bg-card: #ffffff;
      --bg-card-soft: #f9fafb;
      --text: #111827;
      --text-soft: #6b7280;
      --border: #e5e7eb;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #111827, var(--bg));
      color: var(--text);
      display: flex;
      min-height: 100vh;
      justify-content: center;
      align-items: flex-start;
    }

    .app-shell {
      width: 100%;
      max-width: 480px;
      margin: 16px;
      border-radius: 24px;
      background: linear-gradient(145deg, #020617, #020617);
      box-shadow: 0 24px 80px rgba(0,0,0,0.65);
      overflow: hidden;
      border: 1px solid rgba(148,163,184,0.25);
    }

    header {
      padding: 14px 18px 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: radial-gradient(circle at top left,#1e293b,var(--bg-card));
    }

    header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .app-title {
      font-size: 18px;
      font-weight: 700;
    }

    .subtitle {
      font-size: 11px;
      color: var(--text-soft);
    }

    .pill-toggle {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      color: var(--text-soft);
    }

    .pill-toggle span.icon {
      font-size: 13px;
    }

    .patient-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 4px;
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      background: linear-gradient(145deg,#22c55e,#16a34a);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #f9fafb;
      font-weight: 700;
      font-size: 15px;
      flex-shrink: 0;
    }

    .patient-select {
      flex: 1;
      background: rgba(15,23,42,0.95);
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-soft);
    }

    .patient-select select {
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      font-size: 13px;
      outline: none;
      appearance: none;
    }

    .patient-select span.chevron {
      margin-left: 8px;
      font-size: 11px;
      opacity: 0.7;
    }

    main.app-body {
      padding: 12px 14px 16px;
      background: radial-gradient(circle at top,#020617,var(--bg-card-soft));
    }

    .nav {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
      margin-bottom: 10px;
    }

    .nav button {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 11px;
      padding: 7px 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
    }

    .nav button.active {
      background: linear-gradient(135deg,var(--accent),var(--accent-strong));
      color: #f9fafb;
      border-color: transparent;
    }

    .nav button span.icon {
      font-size: 13px;
    }

    .screen {
      display: none;
      margin-top: 6px;
    }

    .screen.active {
      display: block;
    }

    .card {
      background: rgba(15,23,42,0.9);
      border-radius: 18px;
      padding: 12px 12px 10px;
      border: 1px solid var(--border);
      margin-bottom: 10px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card-title span.icon {
      font-size: 14px;
    }

    .chip {
      font-size: 10px;
      color: var(--text-soft);
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px dashed rgba(148,163,184,0.4);
    }

    label {
      font-size: 11px;
      color: var(--text-soft);
      display: block;
      margin-top: 6px;
      margin-bottom: 2px;
    }

    input[type="text"],
    input[type="date"],
    input[type="time"],
    input[type="number"],
    input[type="tel"],
    select,
    textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.95);
      color: var(--text);
      padding: 7px 9px;
      font-size: 12px;
      outline: none;
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    input[type="file"] {
      font-size: 11px;
      color: var(--text-soft);
    }

    .row {
      display: flex;
      gap: 8px;
    }

    .row > div {
      flex: 1;
    }

    .hint {
      font-size: 10px;
      color: var(--text-soft);
      margin-top: 3px;
    }

    .btn-primary,
    .btn-secondary {
      margin-top: 8px;
      width: 100%;
      border-radius: 999px;
      border: none;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn-primary {
      background: linear-gradient(135deg,var(--accent),var(--accent-strong));
      color: #f9fafb;
    }

    .btn-secondary {
      background: rgba(15,23,42,0.9);
      border: 1px solid var(--border);
      color: var(--text-soft);
    }

    .btn-row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .btn-row .btn-secondary {
      flex: 1;
      margin-top: 0;
    }

    .list {
      margin-top: 6px;
      max-height: 210px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .list-item {
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 6px 8px;
      font-size: 11px;
      margin-bottom: 4px;
      background: rgba(15,23,42,0.9);
    }

    .list-item strong {
      font-size: 11px;
    }

    .badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid var(--border);
      margin-left: 4px;
      color: var(--text-soft);
    }

    .badge-danger {
      border-color: rgba(248,113,113,0.65);
      color: #fecaca;
      background: rgba(127,29,29,0.35);
    }

    .mini {
      font-size: 10px;
      color: var(--text-soft);
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      font-size: 11px;
      color: var(--text-soft);
    }

    .checkbox-row input {
      width: 14px;
      height: 14px;
    }

    footer {
      padding: 4px 12px 10px;
      font-size: 9px;
      color: var(--text-soft);
      text-align: center;
      background: #020617;
      border-top: 1px solid var(--border);
    }

    /* Styles pour la modale du graphique */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.75); /* Fond assombri */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      visibility: hidden; /* Cach√© par d√©faut */
      opacity: 0;
      transition: visibility 0s, opacity 0.3s ease;
    }

    .modal-overlay.active {
      visibility: visible;
      opacity: 1;
    }

    .modal-content {
      background-color: var(--bg-card);
      border-radius: 18px;
      padding: 15px;
      width: 90%;
      max-width: 600px; /* Taille maximale */
      max-height: 90%;
      overflow-y: auto; /* Scroll interne si contenu long */
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 15px;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.2em;
      color: var(--text);
    }

    .modal-close-btn {
      background: none;
      border: none;
      font-size: 1.5em;
      color: var(--text-soft);
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .modal-body {
      flex-grow: 1;
      overflow-y: auto; /* Permet le d√©filement du contenu du corps si n√©cessaire */
    }
  </style>
</head>
<body class="">
  <div class="app-shell">
    <header>
      <header-top>
        <div>
          <div class="app-title">Mini MesTransmissions</div>
          <div class="subtitle">Version App iPhone ‚Äî 100% locale</div>
        </div>
        <button id="btnTheme" class="pill-toggle">
          <span class="icon">üí°</span><span>Mode clair</span>
        </button>
      </header-top>

      <div class="patient-row">
        <div class="avatar" id="patientInitial">J</div>
        <div class="patient-select">
          <select id="patientSelect">
            <option value="Jean" selected>Jean</option>
            <option value="Mme L">Mme L</option>
            <option value="Mr S">Mr S</option>
            <option value="Test">Patient test</option>
          </select>
          <span class="chevron">‚ñæ</span>
        </div>
      </div>
    </header>

    <main class="app-body">
      <!-- Navigation -->
      <div class="nav">
        <button class="nav-item active" data-screen="transmissions">
          <span class="icon">‚úçÔ∏è</span><span>Trans</span>
        </button>
        <button class="nav-item" data-screen="constantes">
          <span class="icon">üìä</span><span>Const</span>
        </button>
        <button class="nav-item" data-screen="ordos">
          <span class="icon">üíä</span><span>Ordos</span>
        </button>
        <button class="nav-item" data-screen="rappels">
          <span class="icon">üîî</span><span>Rappels</span>
        </button>
        <button class="nav-item" data-screen="patient">
          <span class="icon">üë§</span><span>Patient</span>
        </button>
      </div>

      <!-- √âCRAN PATIENT -->
      <section class="screen" id="screen-patient">
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üë§</span> Fiche patient
            </div>
            <span class="chip">Infos utiles 15 / GPS</span>
          </div>

          <label for="patientContactPhoto">üì∏ Capture d'√©cran du contact iPhone</label>
          <input type="file" id="patientContactPhoto" accept="image/*" capture="environment" />
          <div class="hint">Prends une photo ou charge une capture d'√©cran du contact. L'IA va remplir les champs automatiquement !</div>
          <button class="btn-secondary" id="btnAnalyzeContact" style="margin-top: 8px;">
            ü§ñ Analyser la capture d'√©cran
          </button>

          <label for="patientPhone">T√©l√©phone du patient</label>
          <input type="tel" id="patientPhone" placeholder="06‚Ä¶" />

          <label for="patientPrescriberPhone">T√©l√©phone service prescripteur</label>
          <input type="tel" id="patientPrescriberPhone" placeholder="Service prescripteur (ex : pneumo Cochin)" />

          <label for="patientAddress">Adresse</label>
          <textarea id="patientAddress" rows="2" placeholder="N¬∞, rue, code postal, ville"></textarea>

          <label for="patientAccess">Acc√®s / codes / √©tage</label>
          <textarea id="patientAccess" rows="2" placeholder="Code porte, interphone, √©tage, digicode, bo√Ætier cl√©‚Ä¶"></textarea>

          <label for="patientNotes">Notes patient</label>
          <textarea id="patientNotes" rows="3" placeholder="Infos importantes, habitudes, contexte‚Ä¶"></textarea>

          <div class="btn-row">
            <button class="btn-secondary" id="btnCopyAddress">üìã Copier adresse</button>
            <button class="btn-secondary" id="btnOpenMaps">üó∫Ô∏è Maps</button>
            <button class="btn-secondary" id="btnOpenWaze">üöó Waze</button>
          </div>

          <button class="btn-primary" id="btnSavePatient">
            üíæ Enregistrer la fiche patient
          </button>
        </div>
      </section>

      <!-- √âCRAN TRANSMISSIONS -->
      <section class="screen active" id="screen-transmissions">
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">‚úçÔ∏è</span> Nouvelle transmission
            </div>
            <span class="chip">Non modifiable apr√®s enregistrement</span>
          </div>

          <div class="row">
            <div>
              <label for="txDate">Date</label>
              <input type="date" id="txDate" />
            </div>
            <div>
              <label for="txTime">Heure</label>
              <input type="time" id="txTime" />
            </div>
          </div>

          <label for="txType">Type de transmission</label>
          <select id="txType">
            <option>Synth√®se de prise en charge</option>
            <option>Synth√®se des 24 h</option>
            <option>Synth√®se des 48 h</option>
            <option>Perfusion ATB</option>
            <option>Perf Nulojix</option>
            <option>Pansement</option>
            <option>Appel patient</option>
            <option>Autre</option>
          </select>

          <label for="txText">Texte de la transmission</label>
          <textarea id="txText" placeholder="√âcris ici ta transmission..."></textarea>

          <div class="hint">
            Astuce : tu peux coller le texte g√©n√©r√© par ChatGPT, puis l'ajuster.
          </div>

          <div class="checkbox-row">
            <input type="checkbox" id="txFlash" />
            <label for="txFlash">Marquer comme importante (Flash Soins)</label>
          </div>

          <button class="btn-primary" id="btnSaveTx">
            üíæ Enregistrer la transmission
          </button>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">‚ö°</span> Flash Soins
            </div>
            <span class="chip">Vue rapide des transmissions importantes</span>
          </div>
          <div id="txFlashList" class="list mini"></div>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üìö</span> Transmissions enregistr√©es
            </div>
          </div>
          <div id="txList" class="list mini"></div>
        </div>
      </section>

      <!-- √âCRAN CONSTANTES -->
      <section class="screen" id="screen-constantes">
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üìä</span> Nouvelles constantes
            </div>
            <span class="chip">Vue IDEL friendly</span>
          </div>

          <div class="row">
            <div>
              <label for="ctDate">Date</label>
              <input type="date" id="ctDate" />
            </div>
            <div>
              <label for="ctTime">Heure</label>
              <input type="time" id="ctTime" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="ctTA">TA (mmHg)</label>
              <input type="text" id="ctTA" placeholder="120/70" />
            </div>
            <div>
              <label for="ctFC">Pouls (BPM)</label>
              <input type="number" id="ctFC" placeholder="80" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="ctSpO2">SpO‚ÇÇ (%)</label>
              <input type="number" id="ctSpO2" placeholder="98" />
            </div>
            <div>
              <label for="ctTemp">Temp√©rature (¬∞C)</label>
              <input type="number" id="ctTemp" placeholder="36.8" step="0.1" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="ctEVA">EVA/EN</label>
              <input type="number" id="ctEVA" placeholder="0-10" min="0" max="10" />
            </div>
            <div>
              <label for="ctPoids">Poids (kg)</label>
              <input type="number" id="ctPoids" placeholder="70" step="0.1" />
            </div>
          </div>

          <div class="checkbox-row">
            <input type="checkbox" id="ctOxy" />
            <label for="ctOxy">Sous O‚ÇÇ</label>
          </div>

          <!-- Champs personnalis√©s dynamiques -->
          <div id="ctCustomFields"></div>

          <div class="btn-row">
            <button class="btn-secondary" id="btnAddCustomField" style="flex: 1;">
              ‚ûï Ajouter un champ
            </button>
          </div>

          <button class="btn-primary" id="btnSaveCt">
            üíæ Enregistrer les constantes
          </button>
        </div>

        <!-- Graphique et historique -->
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üìà</span> Historique constantes
            </div>
            <span class="chip">Graphique & Liste</span>
          </div>
          
          <!-- S√©lecteur de plage de dates -->
          <div style="margin-bottom: 8px;">
            <label style="font-size: 11px; color: var(--text-soft);">P√©riode :</label>
            <div class="btn-row" style="margin-top: 4px;">
              <button class="btn-secondary" id="ctPeriod7" style="flex: 1; margin-top: 0; font-size: 10px; padding: 5px;">7j</button>
              <button class="btn-secondary" id="ctPeriod30" style="flex: 1; margin-top: 0; font-size: 10px; padding: 5px;">30j</button>
              <button class="btn-secondary" id="ctPeriodAll" style="flex: 1; margin-top: 0; font-size: 10px; padding: 5px;">Tout</button>
            </div>
            <div class="row" style="margin-top: 6px;">
              <div>
                <label for="ctDateFrom" style="font-size: 10px; color: var(--text-soft);">Du :</label>
                <input type="date" id="ctDateFrom" style="font-size: 11px; padding: 5px;" />
              </div>
              <div>
                <label for="ctDateTo" style="font-size: 10px; color: var(--text-soft);">Au :</label>
                <input type="date" id="ctDateTo" style="font-size: 11px; padding: 5px;" />
              </div>
            </div>
          </div>
          
          <!-- S√©lecteur de constante √† afficher -->
          <div style="margin-bottom: 8px;">
            <label for="ctGraphType" style="font-size: 11px; color: var(--text-soft);">Afficher :</label>
            <select id="ctGraphType" style="width: 100%; margin-top: 4px;">
              <option value="temp">Temp√©rature</option>
              <option value="ta">Tension Art√©rielle</option>
              <option value="fc">Pouls</option>
              <option value="spo2">SpO‚ÇÇ</option>
              <option value="eva">EVA/EN</option>
              <option value="poids">Poids</option>
            </select>
          </div>

          <!-- Zone graphique simple -->
          <div id="ctGraphContainer" style="height: 160px; margin: 8px 0; background: rgba(15,23,42,0.5); border-radius: 12px; display: flex; align-items: flex-end; justify-content: space-around; padding: 8px; border: 1px solid var(--border); cursor: pointer;">
            <div id="ctGraph" style="width: 100%; height: 100%; display: flex; align-items: flex-end; justify-content: space-around;">
              <div style="text-align: center; font-size: 9px; color: var(--text-soft);">Aucune donn√©e</div>
            </div>
          </div>

          <div id="ctList" class="list mini" style="max-height: 300px;"></div>
        </div>
      </section>

      <!-- √âCRAN ORDOS (ANALYSE TEXTE + OCR IMAGE) -->
      <section class="screen" id="screen-ordos">
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üíä</span> Nouvelle ordonnance
            </div>
            <span class="chip">Lecture & pr√©-remplissage</span>
          </div>

          <label for="ordoTypeTrait">Type de traitement</label>
          <select id="ordoTypeTrait">
            <option value="ATB">Antibiotique</option>
            <option value="ANTICOAG">Anticoagulant</option>
            <option value="ANTALGIQUE">Antalgique</option>
            <option value="AUTRE" selected>Autre</option>
          </select>

          <label for="ordoText">Texte de l'ordonnance</label>
          <textarea
            id="ordoText"
            placeholder="Ex : Augmentin 1 g x 3/j pendant 7 jours √† partir du 12/12/2025..."
          ></textarea>

          <div class="hint">
            Tu peux coller ici un copier/coller de l'ordonnance (messagerie s√©cu, PDF texte, etc.).
          </div>

          <label for="ordoFile">Fichier ordonnance (photo / PDF)</label>
          <input
            type="file"
            id="ordoFile"
            accept="image/*,application/pdf"
            capture="environment"
          />
          <div class="hint">
            Sur iPhone / Android tu peux prendre une photo directe. Sur ordinateur, tu peux choisir un fichier d√©j√† enregistr√©.
            (La V3 lit surtout les images ; pour un PDF, tu peux copier/coller le texte ou faire une capture √©cran.)
          </div>

          <button class="btn-secondary" id="btnAnalyzeOrdo">
            ü§ñ Analyser l'ordonnance (Texte / Photo)
          </button>

          <div class="row">
            <div>
              <label for="ordoMolecule">Mol√©cule</label>
              <input type="text" id="ordoMolecule" />
            </div>
            <div>
              <label for="ordoDose">Dose</label>
              <input type="text" id="ordoDose" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="ordoFreq">Fr√©quence</label>
              <input type="text" id="ordoFreq" placeholder="3x/j" />
            </div>
            <div>
              <label for="ordoDuree">Dur√©e (jours)</label>
              <input type="number" id="ordoDuree" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="ordoDebut">Date de d√©but</label>
              <input type="date" id="ordoDebut" />
            </div>
            <div>
              <label for="ordoFin">Date de fin</label>
              <input type="date" id="ordoFin" />
            </div>
          </div>

          <label for="ordoType">Type d√©tect√©</label>
          <input type="text" id="ordoType" />

          <button class="btn-primary" id="btnSaveOrdo">
            üíæ Enregistrer l'ordonnance
          </button>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üìÇ</span> Ordonnances du patient
            </div>
            <span class="chip">En cours / historiques</span>
          </div>
          <div id="ordoList" class="list mini"></div>
        </div>
      </section>

      <!-- √âCRAN RAPPELS -->
      <section class="screen" id="screen-rappels">
        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">üîî</span> Rappels / M√©mos
            </div>
            <span class="chip">Mini to-do IDEL</span>
          </div>

          <label for="memoText">M√©mo</label>
          <input
            type="text"
            id="memoText"
            placeholder="Ex : Appeler Mme R √† 14 h"
          />

          <button class="btn-primary" id="btnAddMemo">
            ‚ûï Ajouter un rappel
          </button>
        </div>

        <div class="card">
          <div class="card-header">
            <div class="card-title">
              <span class="icon">‚úÖ</span> Rappels en cours
            </div>
          </div>
          <div id="memoList" class="list mini"></div>
        </div>
      </section>
    </main>

    <footer>
      Tout est stock√© localement sur ton appareil (localStorage navigateur).  
      Prototype Seb ‚Äì √† bidouiller sans stress üòä
    </footer>
  </div>

  <!-- Modale pour le graphique agrandi -->
  <div id="graphModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalGraphTitle">Graphique des Constantes</h3>
        <button class="modal-close-btn" id="closeModalBtn">‚úñ</button>
      </div>
      <div class="modal-body">
        <div id="modalCtGraph" style="height: 400px; width: 100%;">
          <!-- Le graphique SVG agrandi sera ins√©r√© ici -->
        </div>
        <div id="modalCtDetails" class="list mini" style="margin-top: 20px;">
          <!-- Les d√©tails des constantes seront ins√©r√©s ici -->
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Helpers
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => document.querySelectorAll(sel);

    function load(key, def) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return def;
        return JSON.parse(raw);
      } catch {
        return def;
      }
    }

    function save(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    // √âtat global
    let currentPatient = "Jean";

    // ---------- PATIENT (s√©lecteur haut) ----------
    const patientSelect = $("#patientSelect");
    const patientInitial = $("#patientInitial");

    patientSelect.addEventListener("change", () => {
      currentPatient = patientSelect.value;
      patientInitial.textContent = currentPatient.trim()[0] || "?";
      renderAll();
    });

    // ---------- FICHE PATIENT ----------
    function getPatientKey() {
      return "seb_app_patient_" + currentPatient;
    }

    function getPatientInfo() {
      return load(getPatientKey(), null);
    }

    function savePatientInfo(data) {
      save(getPatientKey(), data);
    }

    // Fonction pour nettoyer l\'adresse des artefacts OCR
    function cleanAddress(address) {
      if (!address) return "";
      
      // Enlever les artefacts OCR communs
      let cleaned = address
        // Enlever les patterns comme "-0 E", "-0E", etc.
        .replace(/\s*-\s*0\s*[A-Z]\s*,?/gi, "")  // "-0 E"
        .replace(/\s*-\s*0\s*,?/gi, "")  // "-0"
        .replace(/\s*-\s*\d+\s*[A-Z]\s*,?/gi, "")  // "-123 A"
        // Enlever "so AUS res" ou variations
        .replace(/\s+so\s+[A-Z]{2,4}\s+res\s*,?/gi, "")  // "so AUS res"
        .replace(/\s+so\s+[A-Z]+\s*,?/gi, "")  // "so AUS"
        .replace(/\s+[a-z]{1,2}\s+[A-Z]{2,4}\s+[a-z]{1,3}\s*,?/gi, "")  // mots courts isol√©s
        // Enlever les fragments isol√©s qui ne font pas partie d\'une adresse
        .replace(/\s+[A-Z]{1,2}\s+[A-Z]{2,4}\s+[a-z]{1,3}\s*,?/gi, "")  // "AUS res"
        // Nettoyer les espaces multiples
        .replace(/\s+/g, " ")
        .trim()
        // Enlever les virgules en fin
        .replace(/,\s*$/, "")
        // Enlever les virgules multiples
        .replace(/,\s*,/g, ",")
        .trim();
      
      return cleaned;
    }

    // Fonction pour parser un fichier .vcf (vCard)
    function parseVCF(vcfText) {
      const contact = {
        name: "",
        phone: "",
        address: "",
        notes: ""
      };

      // G√©rer les lignes qui se continuent (commencent par espace/tab)
      let fullText = vcfText.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      fullText = fullText.replace(/\n[ \t]/g, ""); // Supprimer les continuations de ligne
      
      const lines = fullText.split("\n");
      
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        if (!line) continue;
        
        // Nom complet (FN)
        if (line.startsWith("FN:") || line.startsWith("FN;")) {
          const nameMatch = line.match(/FN[^:]*:(.+)/);
          if (nameMatch) {
            contact.name = nameMatch[1].trim();
          }
        }
        
        // T√©l√©phone (prendre le premier trouv√©, ou pr√©f√©rer mobile/cell)
        if (line.startsWith("TEL")) {
          const phoneMatch = line.match(/TEL[^:]*:(.+)/);
          if (phoneMatch) {
            let phone = phoneMatch[1].trim();
            // Nettoyer le num√©ro (garder seulement chiffres et +)
            phone = phone.replace(/[^\d+]/g, "");
            // Si c\'est un mobile ou si on n\'a pas encore de t√©l√©phone
            if (line.includes("CELL") || line.includes("MOBILE") || !contact.phone) {
              contact.phone = phone;
            }
          }
        }
        
        // Adresse (ADR)
        if (line.startsWith("ADR") || line.includes("ADR;")) {
          const addrMatch = line.match(/ADR[^:]*:(.+)/);
          if (addrMatch) {
            const addrParts = addrMatch[1].split(";");
            // Format vCard: [type];[label];[boite postale];[num√©ro+rue];[ville];[r√©gion];[code postal];[pays]
            const parts = addrParts.map(p => p.trim()).filter(p => p);
            
            const addrArray = [];
            if (parts[3]) addrArray.push(parts[3]); // Num√©ro + rue
            if (parts[4]) addrArray.push(parts[4]); // Ville
            if (parts[6]) addrArray.push(parts[6]); // Code postal
            if (parts[7] && parts[7] !== "France") addrArray.push(parts[7]); // Pays
            
            contact.address = addrArray.join(", ");
          }
        }
        
        // Notes
        if (line.startsWith("NOTE:")) {
          const noteMatch = line.match(/NOTE:(.+)/);
          if (noteMatch) {
            contact.notes = noteMatch[1].trim();
          }
        }
      }

      return contact;
    }

    function renderPatient() {
      const info = getPatientInfo() || {
        phone: "",
        prescriber: "",
        address: "",
        access: "",
        notes: ""
      };

      const phoneInput = $("#patientPhone");
      const prescInput = $("#patientPrescriberPhone");
      const addrInput = $("#patientAddress");
      const accessInput = $("#patientAccess");
      const notesInput = $("#patientNotes");

      if (phoneInput) phoneInput.value = info.phone || "";
      if (prescInput) prescInput.value = info.prescriber || "";
      if (addrInput) addrInput.value = info.address || "";
      if (accessInput) accessInput.value = info.access || "";
      if (notesInput) notesInput.value = info.notes || "";
    }

    // Fonction pour parser le texte OCR d\'une capture d\'√©cran de contact
    function parseContactFromOCR(ocrText) {
      const contact = {
        name: "",
        phone: "",
        address: "",
        access: "",
        notes: ""
      };

      const lines = ocrText.split(/\n/).map(l => l.trim()).filter(l => l);
      const fullText = ocrText;

      // Chercher le t√©l√©phone - approche flexible
      let phoneFound = false;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].toLowerCase();
        if (/portable|mobile/i.test(line)) {
          let phoneMatch = lines[i].match(/(\d[\d\s]{8,}\d)/);
          if (!phoneMatch && i + 1 < lines.length) {
            phoneMatch = lines[i + 1].match(/(\d[\d\s]{8,}\d)/);
          }
          if (phoneMatch) {
            let phone = phoneMatch[1].replace(/\s/g, "").replace(/[^\d+]/g, "");
            if (phone.startsWith("+33")) {
              phone = "0" + phone.substring(3);
            }
            if (phone.length === 10 && phone.startsWith("0")) {
              phone = phone.match(/.{1,2}/g)?.join(" ") || phone;
              contact.phone = phone;
              phoneFound = true;
              break;
            }
          }
        }
      }
      
      if (!phoneFound) {
        const phonePatterns = [
          /0[1-9]\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}/g,
          /0[1-9]\d{8}/g,
          /\+33\s?[1-9]\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}/g
        ];
        for (const pattern of phonePatterns) {
          const matches = fullText.match(pattern);
          if (matches && matches.length > 0) {
            for (const match of matches) {
              let phone = match.replace(/\s/g, "");
              if (phone.startsWith("+33")) {
                phone = "0" + phone.substring(3);
              }
              if (phone.length === 10 && phone.startsWith("0") && /^0[67]/.test(phone)) {
                phone = phone.match(/.{1,2}/g)?.join(" ") || phone;
                contact.phone = phone;
                break;
              }
            }
            if (contact.phone) break;
          }
        }
      }

      // Chercher l\'adresse
      let addressFound = false;
      let addressLines = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].toLowerCase();
        if (/^domicile$/i.test(lines[i])) {
          for (let j = i + 1; j < Math.min(i + 6, lines.length); j++) {
            const addrLine = lines[j];
            if (/^(escalier|porte|interphone|√©tage|domicile|portable|mobile)$/i.test(addrLine)) {
              break;
            }
            if (/^\d{5}$/.test(addrLine)) {
              addressLines.push(addrLine);
              if (j + 1 < lines.length) {
                const nextLine = lines[j + 1];
                if (nextLine && nextLine.length < 30 && !/^\d+$/.test(nextLine) && 
                    !/^[A-Z]\d+[A-Z]?$/.test(nextLine)) {
                  addressLines.push(nextLine);
                }
              }
              break;
            }
            if (/\d+\s*[Rr]ue|[Aa]venue|[Bb]oulevard/i.test(addrLine) ||
                (/^\d+/.test(addrLine) && addrLine.length > 8 && !/^\d{1,6}$/.test(addrLine))) {
              addressLines.push(addrLine);
            }
          }
          if (addressLines.length > 0) {
            contact.address = addressLines.join(", ");
            addressFound = true;
            break;
          }
        }
      }
      
      if (!addressFound) {
        for (let i = 0; i < lines.length - 1; i++) {
          const line1 = lines[i];
          const line2 = lines[i + 1];
          if (/\d+\s*[Rr]ue|[Aa]venue|[Bb]oulevard/i.test(line1) && /^\d{5}$/.test(line2)) {
            const addrParts = [line1, line2];
            if (i + 2 < lines.length) {
              const line3 = lines[i + 2];
              if (line3 && line3.length < 30 && !/^\d+$/.test(line3) && 
                  !/^[A-Z]\d+[A-Z]?$/.test(line3) && !/^(escalier|porte|interphone|√©tage)$/i.test(line3)) {
                addrParts.push(line3);
              }
            }
            contact.address = addrParts.join(", ");
            break;
          }
        }
      }

      // Extraire les codes d\'acc√®s
      const accessParts = [];
      
      // D\'abord chercher le code domicile (appara√Æt avant l\'adresse compl√®te)
      // Dans le contact iPhone, il y a souvent "domicile: 7454" puis plus loin "domicile:" avec l\'adresse
      let domicileCodeFound = false;
      
      // Chercher dans tout le texte d\'abord pour trouver tous les "domicile"
      const domicileIndices = [];
      for (let i = 0; i < lines.length; i++) {
        if (/^domicile/i.test(lines[i])) {
          domicileIndices.push(i);
        }
      }
      
      // Si on trouve plusieurs "domicile", le premier avec un code court est probablement le code domicile
      for (const idx of domicileIndices) {
        if (domicileCodeFound) break;
        
        const line = lines[idx];
        
        // Chercher code sur la m√™me ligne : "domicile: 7454" ou "domicile 7454"
        const sameLineMatch = line.match(/domicile[:\s]+(\d{1,6})/i);
        if (sameLineMatch) {
          const code = sameLineMatch[1];
          // Si c\'est un code court (1-4 chiffres ou 6 chiffres, pas 5 qui pourrait √™tre un code postal)
          if (/^\d{1,4}$/.test(code) || /^\d{6}$/.test(code)) {
            // V√©rifier que la ligne suivante n\'est pas une adresse
            let isAddress = false;
            if (idx + 1 < lines.length) {
              const nextLine = lines[idx + 1];
              if (/\d+\s*[Rr]ue|[Aa]venue|[Bb]oulevard/i.test(nextLine)) {
                isAddress = true;
              }
            }
            if (!isAddress) {
              accessParts.push("Code domicile: " + code);
              domicileCodeFound = true;
              break;
            }
          }
        }
        
        // Chercher code sur la ligne suivante : "domicile" puis "7454"
        if (!domicileCodeFound && idx + 1 < lines.length) {
          const nextLine = lines[idx + 1];
          // Code court (1-4 ou 6 chiffres)
          if (/^\d{1,4}$/.test(nextLine) || /^\d{6}$/.test(nextLine)) {
            // V√©rifier que ce n\'est pas suivi d\'une adresse
            let isAddress = false;
            if (idx + 2 < lines.length) {
              const lineAfter = lines[idx + 2];
              if (/\d+\s*[Rr]ue|[Aa]venue|[Bb]oulevard/i.test(lineAfter)) {
                isAddress = true;
              }
            }
            if (!isAddress) {
              accessParts.push("Code domicile: " + nextLine);
              domicileCodeFound = true;
              break;
            }
          }
        }
      }
      
      // Ensuite chercher les autres codes d\'acc√®s
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineLower = line.toLowerCase();
        
        if (/escalier/i.test(line)) {
          let escalierMatch = line.match(/escalier[:\s]*(\d+[A-Z]?)/i);
          if (!escalierMatch && i + 1 < lines.length && /^\d+[A-Z]?$/.test(lines[i + 1])) {
            escalierMatch = [null, lines[i + 1]];
          }
          if (escalierMatch) {
            accessParts.push("Escalier: " + escalierMatch[1]);
          }
        }
        
        if (/porte/i.test(line) && !/interphone/i.test(line)) {
          let porteMatch = line.match(/porte[:\s]*([A-Z]?\d+[A-Z]?)/i);
          if (!porteMatch && i + 1 < lines.length && /^[A-Z]?\d+[A-Z]?$/.test(lines[i + 1])) {
            porteMatch = [null, lines[i + 1]];
          }
          if (porteMatch) {
            accessParts.push("Porte: " + porteMatch[1]);
          }
        }
        
        if (/interphone/i.test(line)) {
          let interphoneMatch = line.match(/interphone[:\s]*([a-z√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß\s]+)/i);
          if (!interphoneMatch && i + 1 < lines.length && /^[a-z√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]+$/i.test(lines[i + 1])) {
            interphoneMatch = [null, lines[i + 1]];
          }
          if (interphoneMatch) {
            accessParts.push("Interphone: " + interphoneMatch[1].trim());
          }
        }
        
        if (/√©tage|etage/i.test(line)) {
          let etageMatch = line.match(/√©tage[:\s]*([^\n]+)/i);
          if (!etageMatch && i + 1 < lines.length && lines[i + 1].length < 20) {
            etageMatch = [null, lines[i + 1]];
          }
          if (etageMatch) {
            accessParts.push("√âtage: " + etageMatch[1].trim());
          }
        }
      }
      
      if (accessParts.length > 0) {
        contact.access = accessParts.join(" | ");
      }

      return contact;
    }

    // Gestion de l\'analyse OCR d\'une capture d\'√©cran de contact
    $("#btnAnalyzeContact")?.addEventListener("click", async () => {
      const fileInput = $("#patientContactPhoto");
      const file = fileInput?.files[0];
      
      if (!file) {
        alert("üì∏ Prends d\'abord une photo ou charge une capture d\'√©cran du contact iPhone.");
        return;
      }

      if (!file.type.startsWith("image/")) {
        alert("‚ö†Ô∏è Veuillez s√©lectionner une image (photo ou capture d\'√©cran).");
        return;
      }

      const btn = $("#btnAnalyzeContact");
      const oldLabel = btn.textContent;
      btn.disabled = true;
      btn.textContent = "ü§ñ Analyse en cours...";

      try {
        const dataURL = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = (e) => reject(e);
          reader.readAsDataURL(file);
        });

        const result = await Tesseract.recognize(dataURL, "fra", {
          logger: (m) => console.log(m),
        });

        const ocrText = (result.data.text || "").trim();

        if (!ocrText || ocrText.length < 10) {
          alert("‚ö†Ô∏è Je n\'ai pas r√©ussi √† lire le texte sur cette image.\n\nAssure-toi que :\n‚Ä¢ La photo est nette\n‚Ä¢ Le texte est bien visible\n‚Ä¢ La capture d\'√©cran montre bien le contact complet");
          btn.disabled = false;
          btn.textContent = oldLabel;
          return;
        }

        const contact = parseContactFromOCR(ocrText);

        let importedCount = 0;
        let importedFields = [];

        if (contact.phone && $("#patientPhone")) {
          $("#patientPhone").value = contact.phone;
          importedCount++;
          importedFields.push("T√©l√©phone");
        }
        
        if (contact.address && $("#patientAddress")) {
          const cleanedAddress = cleanAddress(contact.address);
          $("#patientAddress").value = cleanedAddress;
          importedCount++;
          importedFields.push("Adresse");
        }
        
        if (contact.access && $("#patientAccess")) {
          $("#patientAccess").value = contact.access;
          importedCount++;
          importedFields.push("Acc√®s");
        }
        
        if (contact.notes && $("#patientNotes")) {
          const existingNotes = $("#patientNotes").value.trim();
          $("#patientNotes").value = existingNotes 
            ? existingNotes + "\n\n" + contact.notes 
            : contact.notes;
          importedCount++;
          importedFields.push("Notes");
        }

        if (importedCount > 0) {
          alert("‚úÖ Capture d\'√©cran analys√©e avec succ√®s !\n\n" + 
                (contact.name ? "üë§ " + contact.name + "\n" : "") +
                "üìã Champs remplis: " + importedFields.join(", ") + "\n\n" +
                "Tu peux v√©rifier et ajuster les informations si besoin.");
        } else {
          const showDebug = confirm("‚ö†Ô∏è Je n\'ai pas trouv√© d\'informations dans cette capture.\n\n" +
                "Cliquez sur OK pour voir le texte OCR brut (debug), ou Annuler pour fermer.");
          if (showDebug) {
            alert("üìù Texte OCR brut d√©tect√© :\n\n" + ocrText.substring(0, 500) + 
                  (ocrText.length > 500 ? "\n\n... (tronqu√©)" : ""));
          }
        }

        fileInput.value = "";
        btn.disabled = false;
        btn.textContent = oldLabel;

      } catch (err) {
        console.error(err);
        alert("‚ùå Erreur lors de l\'analyse de l\'image.\n\nEssaie avec une autre photo plus nette.");
        btn.disabled = false;
        btn.textContent = oldLabel;
      }
    });

    $("#btnSavePatient")?.addEventListener("click", () => {
      let address = $("#patientAddress")?.value.trim() || "";
      // Nettoyer l\'adresse avant de sauvegarder
      address = cleanAddress(address);
      
      const data = {
        phone: $("#patientPhone")?.value.trim() || "",
        prescriber: $("#patientPrescriberPhone")?.value.trim() || "",
        address: address,
        access: $("#patientAccess")?.value.trim() || "",
        notes: $("#patientNotes")?.value.trim() || ""
      };
      savePatientInfo(data);
      // Mettre √† jour le champ avec l\'adresse nettoy√©e
      if ($("#patientAddress")) {
        $("#patientAddress").value = address;
      }
      alert("Fiche patient enregistr√©e ‚úÖ");
    });

    $("#btnCopyAddress")?.addEventListener("click", async () => {
      const addr = $("#patientAddress")?.value.trim();
      if (!addr) {
        alert("Aucune adresse √† copier.");
        return;
      }
      try {
        await navigator.clipboard.writeText(addr);
        alert("Adresse copi√©e dans le presse-papiers üëç");
      } catch (e) {
        alert("Impossible de copier automatiquement, s√©lectionne l\'adresse √† la main si besoin.");
      }
    });

    $("#btnOpenMaps")?.addEventListener("click", () => {
      const addr = $("#patientAddress")?.value.trim();
      if (!addr) {
        alert("Ajoute d\'abord une adresse.");
        return;
      }
      const url = "https://www.google.com/maps/dir/?api=1&destination=" +
        encodeURIComponent(addr) +
        "&travelmode=walking";
      window.open(url, "_blank");
    });

    $("#btnOpenWaze")?.addEventListener("click", () => {
      const addr = $("#patientAddress")?.value.trim();
      if (!addr) {
        alert("Ajoute d\'abord une adresse.");
        return;
      }
      const url = "https://waze.com/ul?q=" + encodeURIComponent(addr);
      window.open(url, "_blank");
    });

    // ---------- NAV ----------
    $$(".nav-item").forEach((btn) => {
      btn.addEventListener("click", () => {
        $$(".nav-item").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const screen = btn.dataset.screen;
        $$(".screen").forEach((s) => {
          s.classList.toggle("active", s.id === "screen-" + screen);
        });
      });
    });

    // ---------- TRANSMISSIONS ----------
    function getTx() {
      return load("seb_app_tx", []);
    }

    function saveTx(list) {
      save("seb_app_tx", list);
    }

    $("#btnSaveTx").addEventListener("click", () => {
      const date = $("#txDate").value;
      const time = $("#txTime").value;
      const type = $("#txType").value;
      const text = $("#txText").value.trim();
      const flash = $("#txFlash").checked;

      if (!text) {
        alert("√âcris ta transmission avant d\'enregistrer.");
        return;
      }

      const now = new Date();
      const tx = {
        id: "tx_" + now.getTime(),
        patient: currentPatient,
        date: date || now.toISOString().slice(0, 10),
        time:
          time ||
          String(now.getHours()).padStart(2, "0") +
            ":" +
            String(now.getMinutes()).padStart(2, "0"),
        type,
        text,
        flash,
      };

      const all = getTx();
      all.unshift(tx);
      saveTx(all);

      $("#txText").value = "";
      $("#txFlash").checked = false;
      renderTx();
    });

    function renderTx() {
      const list = getTx().filter((t) => t.patient === currentPatient);
      const zone = $("#txList");
      const zoneFlash = $("#txFlashList");

      if (!list.length) {
        zone.innerHTML =
          "<div class=\"mini\">Aucune transmission enregistr√©e pour ce patient.</div>";
        zoneFlash.innerHTML =
          "<div class=\"mini\">Aucun Flash Soins pour l\'instant.</div>";
        return;
      }

      zone.innerHTML = "";
      zoneFlash.innerHTML = "";

      for (const tx of list) {
        const div = document.createElement("div");
        div.className = "list-item";
        div.innerHTML =
          "<strong>" +
          tx.date +
          " " +
          tx.time +
          "</strong> <span class=\'badge\'>" +
          tx.type +
          "</span><br>" +
          tx.text;
        zone.appendChild(div);

        if (tx.flash) {
          const f = div.cloneNode(true);
          f.querySelector(".badge").classList.add("badge-danger");
          zoneFlash.appendChild(f);
        }
      }

      if (!zoneFlash.innerHTML) {
        zoneFlash.innerHTML =
          "<div class=\"mini\">Aucun Flash Soins pour l\'instant.</div>";
      }
    }

    // ---------- CONSTANTES ----------
    function getCt() {
      return load("seb_app_ct", []);
    }

    function saveCt(list) {
      save("seb_app_ct", list);
    }

    function deleteCt(id) {
      if (confirm("Supprimer cette constante ? Cette action est d√©finitive.")) {
        let allCt = getCt();
        allCt = allCt.filter(ct => ct.id !== id);
        saveCt(allCt);
        renderCt(); // Rafra√Æchir l\'affichage
      }
    }

    // Gestion des champs personnalis√©s pour les constantes
    let customFieldCounter = 0;
    const customFieldTypes = [
      { label: "Redon (ml)", type: "number", placeholder: "0" },
      { label: "Diur√®se (ml)", type: "number", placeholder: "0" },
      { label: "PCA Morphine bolus demand√©", type: "number", placeholder: "0" },
      { label: "PCA Morphine bolus re√ßu", type: "number", placeholder: "0" },
      { label: "PCA Midazolam bolus demand√©", type: "number", placeholder: "0" },
      { label: "PCA Midazolam bolus re√ßu", type: "number", placeholder: "0" },
      { label: "PCA Oxycodone bolus demand√©", type: "number", placeholder: "0" },
      { label: "PCA Oxycodone bolus re√ßu", type: "number", placeholder: "0" },
      { label: "Fr√©quence respi (Mvt/min)", type: "number", placeholder: "0" },
      { label: "Glyc√©mie (g/l)", type: "number", step: "0.1", placeholder: "0" },
      { label: "Glyc√©mie (mmol/l)", type: "number", step: "0.1", placeholder: "0" },
      { label: "Insuline lente (UI)", type: "number", placeholder: "0" },
      { label: "Insuline mixte (UI)", type: "number", placeholder: "0" },
      { label: "Insuline rapide (UI)", type: "number", placeholder: "0" },
      { label: "Autre", type: "text", placeholder: "Valeur" }
    ];

    $("#btnAddCustomField")?.addEventListener("click", () => {
      const container = $("#ctCustomFields");
      const fieldId = "ctCustom_" + customFieldCounter++;
      
      const fieldDiv = document.createElement("div");
      fieldDiv.className = "row";
      fieldDiv.style.marginTop = "6px";
      fieldDiv.id = fieldId;
      
      const selectDiv = document.createElement("div");
      selectDiv.style.flex = "2";
      
      const select = document.createElement("select");
      select.style.width = "100%";
      customFieldTypes.forEach((type, idx) => {
        const option = document.createElement("option");
        option.value = idx;
        option.textContent = type.label;
        select.appendChild(option);
      });
      selectDiv.appendChild(select);
      
      const inputDiv = document.createElement("div");
      inputDiv.style.flex = "1";
      
      const input = document.createElement("input");
      const selectedType = customFieldTypes[0];
      input.type = selectedType.type;
      input.placeholder = selectedType.placeholder;
      if (selectedType.step) input.step = selectedType.step;
      input.style.width = "100%";
      input.className = "custom-field-input";
      
      select.addEventListener("change", () => {
        const type = customFieldTypes[parseInt(select.value)];
        input.type = type.type;
        input.placeholder = type.placeholder;
        if (type.step) input.step = type.step;
        else input.removeAttribute("step");
      });
      
      inputDiv.appendChild(input);
      
      const removeBtn = document.createElement("button");
      removeBtn.textContent = "‚úï";
      removeBtn.style.cssText = "background: rgba(249,115,115,0.2); border: 1px solid var(--danger); color: var(--danger); border-radius: 8px; padding: 6px 10px; cursor: pointer; font-size: 12px;";
      removeBtn.addEventListener("click", () => {
        fieldDiv.remove();
      });
      
      fieldDiv.appendChild(selectDiv);
      fieldDiv.appendChild(inputDiv);
      fieldDiv.appendChild(removeBtn);
      
      container.appendChild(fieldDiv);
    });

    $("#btnSaveCt").addEventListener("click", () => {
      const now = new Date();
      const date = $("#ctDate").value || now.toISOString().slice(0, 10);
      const time =
        $("#ctTime").value ||
        String(now.getHours()).padStart(2, "0") +
          ":" +
          String(now.getMinutes()).padStart(2, "0");
      const ta = $("#ctTA").value.trim();
      const fc = $("#ctFC").value.trim();
      const spo2 = $("#ctSpO2").value.trim();
      const temp = $("#ctTemp").value.trim();
      const eva = $("#ctEVA").value.trim();
      const poids = $("#ctPoids").value.trim();
      const oxy = $("#ctOxy").checked;

      if (!ta && !fc && !spo2 && !temp && !eva && !poids) {
        alert("Renseigne au moins une constante.");
        return;
      }

      // R√©cup√©rer les champs personnalis√©s
      const customFields = {};
      $$("#ctCustomFields .row").forEach((row) => {
        const select = row.querySelector("select");
        const input = row.querySelector(".custom-field-input");
        if (select && input && input.value.trim()) {
          const fieldName = customFieldTypes[parseInt(select.value)].label;
          customFields[fieldName] = input.value.trim();
        }
      });

      const ct = {
        id: "ct_" + now.getTime(),
        patient: currentPatient,
        date,
        time,
        measurementDateTime: new Date(date + " " + time).toISOString(), // Date/heure de la mesure
        entryDateTime: now.toISOString(), // Date/heure de saisie (technique)
        ta,
        fc,
        spo2,
        temp,
        eva,
        poids,
        oxy,
        custom: customFields
      };

      const all = getCt();
      all.unshift(ct);
      saveCt(all);
      
      // R√©initialiser le formulaire
      $("#ctTA").value = "";
      $("#ctFC").value = "";
      $("#ctSpO2").value = "";
      $("#ctTemp").value = "";
      $("#ctEVA").value = "";
      $("#ctPoids").value = "";
      $("#ctOxy").checked = false;
      $("#ctCustomFields").innerHTML = "";
      
      renderCt();
    });

    // Fonction pour filtrer les donn√©es par plage de dates
    function filterByDateRange(data, dateFrom, dateTo) {
      if (!dateFrom && !dateTo) return data;
      
      return data.filter(ct => {
        // Utiliser measurementDateTime pour le filtrage
        const ctDateTime = new Date(ct.measurementDateTime);
        ctDateTime.setSeconds(0, 0); // Ignorer les secondes et millisecondes pour la comparaison
        
        if (dateFrom) {
          const from = new Date(dateFrom);
          from.setHours(0, 0, 0, 0);
          if (ctDateTime < from) return false;
        }
        
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          if (ctDateTime > to) return false;
        }
        
        return true;
      });
    }

    // Fonction pour dessiner un graphique simple
    function drawSimpleGraph(data, type, containerElement, graphWidth, graphHeight) {
      if (!data || data.length === 0) {
        containerElement.innerHTML = '<div style="text-align: center; font-size: 9px; color: var(--text-soft); padding: 40px 0;">Aucune donn√©e</div>';
        return;
      }

      // Trier par date/heure de mesure
      const sorted = [...data].sort((a, b) => {
        const dateA = new Date(a.measurementDateTime);
        const dateB = new Date(b.measurementDateTime);
        return dateA - dateB;
      });

      // Extraire les valeurs selon le type et cr√©er une liste de points enrichis
      const chartPoints = [];
      sorted.forEach(ct => {
        let primaryValue = null;
        let secondaryValue = null; // Pour la diastolique

        if (type === "temp" && ct.temp) primaryValue = parseFloat(ct.temp);
        else if (type === "ta" && ct.ta) {
          const taMatch = ct.ta.match(/(\d+)\/(\d+)/);
          if (taMatch) {
            primaryValue = parseFloat(taMatch[1]); // Systolique
            secondaryValue = parseFloat(taMatch[2]); // Diastolique
          }
        }
        else if (type === "fc" && ct.fc) primaryValue = parseFloat(ct.fc);
        else if (type === "spo2" && ct.spo2) primaryValue = parseFloat(ct.spo2);
        else if (type === "eva" && ct.eva) primaryValue = parseFloat(ct.eva);
        else if (type === "poids" && ct.poids) primaryValue = parseFloat(ct.poids);

        if (primaryValue !== null) {
          const dateTime = new Date(ct.measurementDateTime); // Utiliser measurementDateTime
          chartPoints.push({
            timestamp: dateTime.getTime(),
            dateLabel: dateTime.toLocaleDateString(\'fr-FR\', { day: \'2-digit\', month: \'2-digit\', hour: \'2-digit\', minute: \'2-digit\' }),
            primaryValue: primaryValue,
            secondaryValue: secondaryValue, // Sera null sauf pour TA
            fullCt: ct // Garder l\'objet ct complet pour les tooltips ou autres besoins
          });
        }
      });

      if (chartPoints.length === 0) {
        containerElement.innerHTML = '<div style="text-align: center; font-size: 9px; color: var(--text-soft); padding: 40px 0;">Aucune donn√©e pour ce type</div>';
        return;
      }

      // Maintenant, `values` et `labels` ne sont plus n√©cessaires, nous utiliserons `chartPoints`
      // Calculer min/max pour l\'√©chelle sur les valeurs primaires (et secondaires si TA)
      const allValuesForScale = chartPoints.flatMap(p => {
        if (type === "ta" && p.secondaryValue !== null) {
          return [p.primaryValue, p.secondaryValue];
        } else {
          return [p.primaryValue];
        }
      });

      const min = Math.min(...allValuesForScale);
      const max = Math.max(...allValuesForScale);
      const range = max - min || 1;
      const padding = range * 0.1; // Pour le calcul de l\'√©chelle du graphique

      // Calcul de la moyenne (toujours disponible)
      const avg = allValuesForScale.reduce((a, b) => a + b, 0) / allValuesForScale.length;

      // Cr√©er le graphique avec ligne de tendance
      const color = type === "temp" ? "#3b82f6" : type === "ta" ? "#8b5cf6" : type === "fc" ? "#ef4444" : type === "spo2" ? "#10b981" : type === "eva" ? "#f59e0b" : "#6366f1";
      
      // Unit√©s pour l\'axe Y
      let unit = "";
      if (type === "temp") unit = "¬∞C";
      else if (type === "ta") unit = "mmHg"; // On affiche la systolique
      else if (type === "fc") unit = "BPM";
      else if (type === "spo2") unit = "%";
      else if (type === "poids") unit = "kg";
      else if (type === "eva") unit = ""; // Pas d\'unit√© sp√©cifique pour EVA/EN

      // Cr√©er un SVG pour le graphique en ligne
      const svgWidth = graphWidth || 400; // Utiliser le param√®tre ou une valeur par d√©faut
      const svgHeight = graphHeight || 160; // Utiliser le param√®tre ou une valeur par d√©faut
      const svgPadding = 60; // Augmenter le padding pour l\'axe Y et le centrage
      const chartWidth = svgWidth - svgPadding * 2;
      const chartHeight = svgHeight - svgPadding * 2;
      
      let svg = `<svg width="${svgWidth}" height="${svgHeight}" style="max-width: 100%; height: auto;">`;
      
      // Dessiner l\'axe Y (lignes horizontales et labels)
      const numTicks = 4; // Nombre de graduations
      for (let i = 0; i <= numTicks; i++) {
        const yValue = min + (range / numTicks) * i;
        const yPos = svgHeight - svgPadding - ((yValue - min + padding) / (range + padding * 2)) * chartHeight;
        
        // Ligne horizontale
        svg += `<line x1="${svgPadding}" y1="${yPos}" x2="${svgWidth - svgPadding}" y2="${yPos}" stroke="var(--border)" stroke-width="0.5" opacity="0.5"/>`;
        
        // Label sur l\'axe Y
        let displayValue = yValue.toFixed(1);
        if (type === "spo2" || type === "fc" || type === "eva") {
          displayValue = yValue.toFixed(0); // Pas de d√©cimales
        } else if (type === "temp" || type === "poids") {
          displayValue = yValue.toFixed(1); // Une d√©cimale
        }

        // Ne pas afficher les labels de l\'axe Y pour la tension art√©rielle
        if (type !== "ta") {
          svg += `<text x="${svgPadding - 10}" y="${yPos + 3}" text-anchor="end" font-size="9" fill="var(--text-soft)">${displayValue}${unit}</text>`;
        }
      }
      
      // Ligne de r√©f√©rence (moyenne)
      if (type !== "ta") { // Ne pas afficher la ligne de r√©f√©rence pour la tension art√©rielle
        const avgY = svgHeight - svgPadding - ((avg - min + padding) / (range + padding * 2)) * chartHeight;
        svg += `<line x1="${svgPadding}" y1="${avgY}" x2="${svgWidth - svgPadding}" y2="${avgY}" stroke="${color}" stroke-width="1" stroke-dasharray="2,2" opacity="0.3"/>`;
      }
      
      // Calculer les positions x,y pour chaque point
      const calculatedPoints = chartPoints.map((p, idx) => {
        const x = svgPadding + (idx / (chartPoints.length - 1 || 1)) * chartWidth;
        const y = svgHeight - svgPadding - ((p.primaryValue - min + padding) / (range + padding * 2)) * chartHeight;
        let secondaryY = null;
        if (type === "ta" && p.secondaryValue !== null) {
            secondaryY = svgHeight - svgPadding - ((p.secondaryValue - min + padding) / (range + padding * 2)) * chartHeight;
        }
        return { ...p, x, y, secondaryY }; 
      });
      
      // Ligne de tendance
      if (calculatedPoints.length > 1) {
        // Zone ombr√©e pour la temp√©rature
        if (type === "temp") {
          let areaPath = `M ${calculatedPoints[0].x} ${svgHeight - svgPadding}`;
          areaPath += ` L ${calculatedPoints[0].x} ${calculatedPoints[0].y}`;
          for (let i = 1; i < calculatedPoints.length; i++) {
            areaPath += ` L ${calculatedPoints[i].x} ${calculatedPoints[i].y}`;
          }
          areaPath += ` L ${calculatedPoints[calculatedPoints.length - 1].x} ${svgHeight - svgPadding} Z`;
          svg += `<path d="${areaPath}" fill="${color}" opacity="0.1"/>`;
        }

        let path = `M ${calculatedPoints[0].x} ${calculatedPoints[0].y}`;
        for (let i = 1; i < calculatedPoints.length; i++) {
          path += ` L ${calculatedPoints[i].x} ${calculatedPoints[i].y}`;
        }
        svg += `<path d="${path}" fill="none" stroke="${color}" stroke-width="2" opacity="0.6"/>`;

        // Deuxi√®me ligne pour la tension art√©rielle (diastolique)
        if (type === "ta") {
            let secondaryPath = `M ${calculatedPoints[0].x} ${calculatedPoints[0].secondaryY}`;
            for (let i = 1; i < calculatedPoints.length; i++) {
                secondaryPath += ` L ${calculatedPoints[i].x} ${calculatedPoints[i].secondaryY}`;
            }
            svg += `<path d="${secondaryPath}" fill="none" stroke="#ef4444" stroke-width="2" opacity="0.6" stroke-dasharray="5,5"/>`; // Couleur rouge, points
        }
      }
      
      // Points
      calculatedPoints.forEach((pt, idx) => {
        svg += `<circle cx="${pt.x}" cy="${pt.y}" r="4" fill="${color}" stroke="#fff" stroke-width="1.5"/>`;
        
        // Label de valeur au-dessus du point (primaire)
        let pointValueDisplayPrimary = pt.primaryValue.toFixed(1);
        if (type === "spo2" || type === "fc" || type === "eva") {
          pointValueDisplayPrimary = pt.primaryValue.toFixed(0);
        } else if (type === "temp" || type === "poids") {
          pointValueDisplayPrimary = pt.primaryValue.toFixed(1);
        }
        svg += `<text x="${pt.x}" y="${pt.y - 10}" text-anchor="middle" font-size="8" fill="var(--text-soft)">${pointValueDisplayPrimary}</text>`;

        // Deuxi√®me point et label pour la tension art√©rielle (diastolique)
        if (type === "ta" && pt.secondaryValue !== null) {
            svg += `<circle cx="${pt.x}" cy="${pt.secondaryY}" r="4" fill="#ef4444" stroke="#fff" stroke-width="1.5"/>`;
            // Label de valeur au-dessus du point (secondaire)
            let pointValueDisplaySecondary = pt.secondaryValue.toFixed(0);
            svg += `<text x="${pt.x}" y="${pt.secondaryY + 15}" text-anchor="middle" font-size="8" fill="var(--text-soft)">${pointValueDisplaySecondary}</text>`;
        }

        // Tooltip au survol (titre)
        let tooltipValue = pt.primaryValue.toFixed(1);
        if (type === "spo2" || type === "fc" || type === "eva") {
          tooltipValue = pt.primaryValue.toFixed(0);
        } else if (type === "temp" || type === "poids") {
          tooltipValue = pt.primaryValue.toFixed(1);
        }
        if (type === "ta" && pt.fullCt.ta) {
          tooltipValue = pt.fullCt.ta; // Afficher la tension compl√®te
        } else {
          tooltipValue += unit;
        }

        svg += `<title>${pt.dateLabel}: ${tooltipValue}</title>`;
      });
      
      // Labels des dates (tous les N points pour √©viter la surcharge)
      const labelStep = Math.max(1, Math.floor(calculatedPoints.length / (graphWidth === 400 ? 6 : 12))); // Plus de labels en grand
      calculatedPoints.forEach((pt, idx) => {
        if (idx % labelStep === 0 || idx === calculatedPoints.length - 1) {
          svg += `<text x="${pt.x}" y="${svgHeight - 5}" text-anchor="middle" font-size="8" fill="var(--text-soft)">${pt.dateLabel}</text>`;
        }
      });
      
      svg += `</svg>`;
      
      containerElement.innerHTML = svg;
    }

    function renderCt() {
      console.log("renderCt() appel√©e."); // Debug pour le probl√®me de la page Constantes
      const allList = getCt().filter((c) => c.patient === currentPatient);
      const zone = $("#ctList");
      const graphZone = $("#ctGraph"); // Cible le div interne pour le graphique principal
      const graphType = $("#ctGraphType")?.value || "temp";
      
      // Filtrer par plage de dates
      const dateFrom = $("#ctDateFrom")?.value || "";
      const dateTo = $("#ctDateTo")?.value || "";
      const list = filterByDateRange(allList, dateFrom, dateTo);

      if (!list.length) {
        zone.innerHTML =
          '<div class="mini">Aucune constante enregistr√©e pour cette p√©riode.</div>';
        if (graphZone) {
          graphZone.innerHTML = '<div style="text-align: center; font-size: 9px; color: var(--text-soft); padding: 40px 0;">Aucune donn√©e pour cette p√©riode</div>';
        }
        return;
      }

      // Dessiner le graphique principal (petite taille)
      if (graphZone) {
        drawSimpleGraph(list, graphType, graphZone, 400, 160); // Appel avec dimensions sp√©cifiques
      }

      // Afficher la liste
      zone.innerHTML = "";
      for (const c of list) {
        const div = document.createElement("div");
        div.className = "list-item";
        div.setAttribute("data-id", c.id); // Ajout de l\'ID pour la suppression

        let constantsLine = "";
        if (c.ta) constantsLine += "TA " + c.ta + " mmHg ";
        if (c.fc) constantsLine += "| Pouls " + parseFloat(c.fc).toFixed(0) + " BPM ";
        if (c.spo2) constantsLine += "| SpO‚ÇÇ " + parseFloat(c.spo2).toFixed(0) + "% ";
        if (c.temp) constantsLine += "| T¬∞ " + parseFloat(c.temp).toFixed(1) + "¬∞C ";
        if (c.eva) constantsLine += "| EVA/EN " + parseFloat(c.eva).toFixed(0) + " ";
        if (c.poids) constantsLine += "| Poids " + parseFloat(c.poids).toFixed(1) + " kg ";
        if (c.oxy) constantsLine += "<span class=\'badge\'>O‚ÇÇ</span> ";

        // Afficher les champs personnalis√©s
        if (c.custom) {
          for (const [key, value] of Object.entries(c.custom)) {
            constantsLine += "| " + key + ": " + value + " ";
          }
        }

        // Supprimer le premier \'|\' si pr√©sent
        if (constantsLine.startsWith("| ")) {
          constantsLine = constantsLine.substring(2);
        }

        // Ligne de la date et de l\'heure
        const dateTimeLine = `<strong>${c.date} ${c.time}</strong> <span class=\'badge\'>Constantes</span>`;

        // Ic√¥ne de suppression
        const deleteIcon = `<span class="delete-icon" data-id="${c.id}" style="float: right; color: var(--text-soft); cursor: pointer; margin-left: 8px;">üóëÔ∏è</span>`;

        div.innerHTML = constantsLine.trim() + deleteIcon + "<br>" + dateTimeLine;
        zone.appendChild(div);
      }

      // Attacher les √©couteurs d\'√©v√©nements pour les ic√¥nes de suppression
      $$(".delete-icon").forEach(icon => {
        icon.addEventListener("click", (event) => {
          const idToDelete = event.target.dataset.id;
          deleteCt(idToDelete);
        });
      });
    }

    // ---------- ORDOS (analyse texte + OCR) ----------
    function getOrdos() {
      return load("seb_app_ordos", []);
    }

    function saveOrdos(list) {
      save("seb_app_ordos", list);
    }

    function parseOrdo(text) {
      const lower = text.toLowerCase();

      // Mol√©cule (liste simple)
      const molecules = [
        "augmentin",
        "amoxicilline",
        "ceftriaxone",
        "tazocilline",
        "tazobactam",
        "ciprofloxacine",
        "levofloxacine",
      ];
      let molecule = "";
      for (const m of molecules) {
        if (lower.includes(m)) {
          molecule = m.charAt(0).toUpperCase() + m.slice(1);
          break;
        }
      }

      // Dose
      let dose = "";
      const doseMatch = text.match(/(\d+[,\.]?\d*)\s*(mg|g|¬µg|ui)/i);
      if (doseMatch) dose = doseMatch[0].replace(",", ".");

      // Fr√©quence
      let freq = "";
      if (/x\s*3\/j|3x\/j|3\*\/j|3 fois par jour/i.test(text)) freq = "3x/j";
      else if (/x\s*2\/j|2x\/j|2\*\/j|2 fois par jour/i.test(text))
        freq = "2x/j";
      else if (/1 fois par jour|1x\/j|x\s*1\/j/i.test(text)) freq = "1x/j";
      else if (/matin.*soir|soir.*matin/i.test(lower)) freq = "2x/j (matin/soir)";

      // Dur√©e
      let duree = "";
      let dureeNb = 0;
      let dureeUnit = "j";
      const dMatch = lower.match(/(\d+)\s*(jours?|j|semaines?|sem)/i);
      if (dMatch) {
        dureeNb = parseInt(dMatch[1], 10);
        dureeUnit = /sem/.test(dMatch[0]) ? "sem" : "j";
        duree = String(dureeNb);
      }

      // Date de d√©but
      let debut = "";
      const dateRegex =
        /(\d{1,2})[\/\.-](\d{1,2})[\/\.-](\d{2,4})/;
      const dateMatch = text.match(dateRegex);
      if (dateMatch) {
        const d = dateMatch[1].padStart(2, "0");
        const m = dateMatch[2].padStart(2, "0");
        let y = dateMatch[3];
        if (y.length === 2) y = "20" + y;
        debut = y + "-" + m + "-" + d;
      }

      // Type d√©tect√©
      let type = "";
      if (
        molecule &&
        ["augmentin", "amoxicilline", "ceftriaxone","tazocilline","tazobactam","ciprofloxacine","levofloxacine"].some(
          (m) => lower.includes(m)
        )
      )
        type = "ATB";
      else if (/lovenox|xarelto|eliquis|innohep|h√©parine/i.test(text))
        type = "Anticoagulant";
      else type = $("#ordoTypeTrait").value || "Autre";

      // Calcul date de fin
      let fin = "";
      if (debut && dureeNb) {
        const d0 = new Date(debut);
        if (!isNaN(d0)) {
          if (dureeUnit === "j") d0.setDate(d0.getDate() + dureeNb);
          else d0.setDate(d0.getDate() + dureeNb * 7);
          const yy = d0.getFullYear();
          const mm = String(d0.getMonth() + 1).padStart(2, "0");
          const dd = String(d0.getDate()).padStart(2, "0");
          fin = yy + "-" + mm + "-" + dd;
        }
      }

      return { molecule, dose, freq, duree, debut, fin, type };
    }

    $("#btnAnalyzeOrdo").addEventListener("click", async () => {
      const btn = $("#btnAnalyzeOrdo");

      let raw = $("#ordoText").value.trim();

      // Si aucun texte, on tente de lire un fichier (photo ou PDF)
      if (!raw) {
        const fileInput = $("#ordoFile");
        const file = fileInput ? fileInput.files[0] : null;

        if (!file) {
          alert("Ajoute une photo de l\'ordonnance ou colle le texte.");
          return;
        }

        // Pour l\'instant, on g√®re surtout les images pour l\'OCR
        if (!file.type.startsWith("image/")) {
          alert(
            "Version actuelle : je lis surtout les photos (images). Pour un PDF, fais une capture √©cran ou copie/colle le texte."
          );
          return;
        }

        const oldLabel = btn.textContent;
        btn.disabled = true;
        btn.textContent = "Lecture de l\'image...";

        try {
          const dataURL = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (e) => reject(e);
            reader.readAsDataURL(file);
          });

          const result = await Tesseract.recognize(dataURL, "fra", {
            logger: (m) => console.log(m),
          });

          raw = (result.data.text || "").trim();
          $("#ordoText").value = raw;

          if (!raw) {
            alert(
              "Je n\'ai pas r√©ussi √† lire du texte sur cette image. Essaie avec une photo plus nette ou mieux cadr√©e."
            );
            btn.disabled = false;
            btn.textContent = oldLabel;
            return;
          }
        } catch (err) {
          console.error(err);
          alert(
            "Erreur pendant la lecture de l\'ordonnance. Essaie avec une autre photo."
          );
          btn.disabled = false;
          btn.textContent = oldLabel;
          return;
        }

        btn.disabled = false;
        btn.textContent = oldLabel;
      }

      const res = parseOrdo(raw);
      $("#ordoMolecule").value = res.molecule || "";
      $("#ordoDose").value = res.dose || "";
      $("#ordoFreq").value = res.freq || "";
      $("#ordoDuree").value = res.duree || "";
      $("#ordoDebut").value = res.debut || "";
      $("#ordoFin").value = res.fin || "";
      $("#ordoType").value = res.type || "";
    });

    $("#btnSaveOrdo").addEventListener("click", () => {
      const now = new Date();
      const brut = $("#ordoText").value.trim();
      if (!brut) {
        alert("Pas de texte d\'ordonnance √† enregistrer.");
        return;
      }

      const ordo = {
        id: "o_" + now.getTime(),
        patient: currentPatient,
        date: now.toISOString().slice(0, 10),
        molecule: $("#ordoMolecule").value.trim(),
        dose: $("#ordoDose").value.trim(),
        freq: $("#ordoFreq").value.trim(),
        duree: $("#ordoDuree").value.trim(),
        debut: $("#ordoDebut").value.trim(),
        fin: $("#ordoFin").value.trim(),
        type: $("#ordoType").value.trim() || $("#ordoTypeTrait").value,
        brut,
      };

      const all = getOrdos();
      all.unshift(ordo);
      saveOrdos(all);
      renderOrdos();
      alert("Ordonnance enregistr√©e pour " + currentPatient + ".");
    });

    function renderOrdos() {
      const list = getOrdos().filter((o) => o.patient === currentPatient);
      const zone = $("#ordoList");

      if (!list.length) {
        zone.innerHTML =
          '<div class="mini">Aucune ordonnance enregistr√©e pour ce patient.</div>';
        return;
      }

      zone.innerHTML = "";
      for (const o of list) {
        const div = document.createElement("div");
        div.className = "list-item";
        let line =
          "<strong>" +
          o.date +
          "</strong> <span class=\'badge\'>" +
          (o.type || "Ordo") +
          "</span>";
        if (o.debut && o.fin)
          line +=
            " <span class=\'badge\'>du " +
            o.debut +
            " au " +
            o.fin +
            "</span>";
        line += "<br>";
        if (o.molecule) line += o.molecule + " ";
        if (o.dose) line += o.dose + " ";
        if (o.freq) line += " | " + o.freq + " ";
        if (o.duree) line += " | " + o.duree + " j";
        div.innerHTML = line;
        zone.appendChild(div);
      }
    }

    // ---------- RAPPELS ----------
    function getMemos() {
      return load("seb_app_memos", []);
    }

    function saveMemos(list) {
      save("seb_app_memos", list);
    }

    $("#btnAddMemo").addEventListener("click", () => {
      const text = $("#memoText").value.trim();
      if (!text) return;
      const now = new Date();
      const memo = {
        id: "m_" + now.getTime(),
        patient: currentPatient,
        text,
      };
      const all = getMemos();
      all.unshift(memo);
      saveMemos(all);
      $("#memoText").value = "";
      renderMemos();
    });

    function renderMemos() {
      const list = getMemos().filter((m) => m.patient === currentPatient);
      const zone = $("#memoList");
      if (!list.length) {
        zone.innerHTML =
          "<div class=\"mini\">Aucun rappel pour l\'instant.</div>";
        return;
      }
      zone.innerHTML = "";
      for (const m of list) {
        const div = document.createElement("div");
        div.className = "list-item";
        div.innerHTML = "‚Ä¢ " + m.text;
        zone.appendChild(div);
      }
    }

    // ---------- THEME ----------
    const btnTheme = $("#btnTheme");
    btnTheme.addEventListener("click", () => {
      document.body.classList.toggle("light");
      const span = btnTheme.querySelector("span:last-child");
      if (document.body.classList.contains("light")) {
        span.textContent = "Mode sombre";
      } else {
        span.textContent = "Mode clair";
      }
    });

    // ---------- INIT ----------
    function renderAll() {
      renderPatient();
      renderTx();
      renderCt();
      renderOrdos();
      renderMemos();
    }

    // G√©rer le changement de type de graphique
    $("#ctGraphType")?.addEventListener("change", () => {
      renderCt();
    });

    // G√©rer les changements de dates
    $("#ctDateFrom")?.addEventListener("change", () => {
      renderCt();
    });
    $("#ctDateTo")?.addEventListener("change", () => {
      renderCt();
    });

    // Boutons de p√©riode rapide
    $("#ctPeriod7")?.addEventListener("click", () => {
      const today = new Date();
      const weekAgo = new Date(today);
      weekAgo.setDate(today.getDate() - 7);
      
      $("#ctDateFrom").value = weekAgo.toISOString().slice(0, 10);
      $("#ctDateTo").value = today.toISOString().slice(0, 10);
      
      // Mettre en √©vidence le bouton actif
      $$("#ctPeriod7, #ctPeriod30, #ctPeriodAll").forEach(btn => {
        btn.classList.remove("active");
      });
      $("#ctPeriod7").classList.add("active");
      
      renderCt();
    });

    $("#ctPeriod30")?.addEventListener("click", () => {
      const today = new Date();
      const monthAgo = new Date(today);
      monthAgo.setDate(today.getDate() - 30);
      
      $("#ctDateFrom").value = monthAgo.toISOString().slice(0, 10);
      $("#ctDateTo").value = today.toISOString().slice(0, 10);
      
      $$("#ctPeriod7, #ctPeriod30, #ctPeriodAll").forEach(btn => {
        btn.classList.remove("active");
      });
      $("#ctPeriod30").classList.add("active");
      
      renderCt();
    });

    $("#ctPeriodAll")?.addEventListener("click", () => {
      $("#ctDateFrom").value = "";
      $("#ctDateTo").value = "";
      
      $$("#ctPeriod7, #ctPeriod30, #ctPeriodAll").forEach(btn => {
        btn.classList.remove("active");
      });
      $("#ctPeriodAll").classList.add("active");
      
      renderCt();
    });

    // ---------- MODALE GRAPHIQUE ----------
    const graphModal = $("#graphModal");
    const closeModalBtn = $("#closeModalBtn");
    const ctGraphContainer = $("#ctGraphContainer");
    const modalCtGraph = $("#modalCtGraph");
    const modalGraphTitle = $("#modalGraphTitle");
    const modalCtDetails = $("#modalCtDetails");

    function openGraphModal() {
      graphModal.classList.add("active");
      document.body.style.overflow = "hidden"; // Emp√™che le d√©filement de la page derri√®re

      // R√©cup√©rer les donn√©es et le type du graphique actuel
      const allList = getCt().filter((c) => c.patient === currentPatient);
      const graphType = $("#ctGraphType")?.value || "temp";
      const dateFrom = $("#ctDateFrom")?.value || "";
      const dateTo = $("#ctDateTo")?.value || "";
      const list = filterByDateRange(allList, dateFrom, dateTo);

      // Mettre √† jour le titre de la modale
      const typeLabel = $("#ctGraphType option:checked")?.textContent || "Constantes";
      modalGraphTitle.textContent = `Graphique des ${typeLabel}`;

      // Dessiner le graphique agrandi dans la modale
      drawSimpleGraph(list, graphType, modalCtGraph, modalCtGraph.offsetWidth, 400); // 400px de hauteur pour la modale
      
      // Afficher les d√©tails des constantes dans la modale
      modalCtDetails.innerHTML = "";
      if (list.length > 0) {
        list.forEach(c => {
          const div = document.createElement("div");
          div.className = "list-item";
          div.setAttribute("data-id", c.id);

          let constantsLine = "";
          if (c.ta) constantsLine += "TA " + c.ta + " mmHg ";
          if (c.fc) constantsLine += "| Pouls " + parseFloat(c.fc).toFixed(0) + " BPM ";
          if (c.spo2) constantsLine += "| SpO‚ÇÇ " + parseFloat(c.spo2).toFixed(0) + "% ";
          if (c.temp) constantsLine += "| T¬∞ " + parseFloat(c.temp).toFixed(1) + "¬∞C ";
          if (c.eva) constantsLine += "| EVA/EN " + parseFloat(c.eva).toFixed(0) + " ";
          if (c.poids) constantsLine += "| Poids " + parseFloat(c.poids).toFixed(1) + " kg ";
          if (c.oxy) constantsLine += "<span class=\'badge\'>O‚ÇÇ</span> ";
          if (c.custom) {
            for (const [key, value] of Object.entries(c.custom)) {
              constantsLine += "| " + key + ": " + value + " ";
            }
          }
          if (constantsLine.startsWith("| ")) {
            constantsLine = constantsLine.substring(2);
          }

          const dateTimeLine = `<strong>${c.date} ${c.time}</strong> <span class=\'badge\'>Constantes</span>`;
          const deleteIcon = `<span class="delete-icon" data-id="${c.id}" style="float: right; color: var(--text-soft); cursor: pointer; margin-left: 8px;">üóëÔ∏è</span>`;

          div.innerHTML = constantsLine.trim() + deleteIcon + "<br>" + dateTimeLine;
          modalCtDetails.appendChild(div);
        });
         // Attacher les √©couteurs d\'√©v√©nements pour les ic√¥nes de suppression dans la modale
        $$("#modalCtDetails .delete-icon").forEach(icon => {
          icon.addEventListener("click", (event) => {
            const idToDelete = event.target.dataset.id;
            deleteCt(idToDelete);
            openGraphModal(); // Recharger la modale apr√®s suppression
          });
        });
      } else {
        modalCtDetails.innerHTML = '<div class="mini">Aucun d√©tail de constante pour cette p√©riode.</div>';
      }
    }

    function closeGraphModal() {
      graphModal.classList.remove("active");
      document.body.style.overflow = "auto"; // R√©tablit le d√©filement de la page
      // Nettoyer le contenu de la modale si n√©cessaire
      modalCtGraph.innerHTML = "";
      modalCtDetails.innerHTML = "";
      renderCt(); // Rafra√Æchir le graphique principal apr√®s fermeture de la modale
    }

        const ctGraphContainerElement = $("#ctGraphContainer");
    if (ctGraphContainerElement) {
      ctGraphContainerElement.addEventListener("click", openGraphModal);
      console.log("√âcouteur d\'√©v√©nement de clic attach√© √† #ctGraphContainer.");
    } else {
      console.log("#ctGraphContainer n\'a pas √©t√© trouv√©. Le clic ne fonctionnera pas.");
    }
    closeModalBtn?.addEventListener("click", closeGraphModal);
    graphModal?.addEventListener("click", (event) => {
      if (event.target === graphModal) {
        closeGraphModal();
      }
    });
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && graphModal.classList.contains("active")) {
        closeGraphModal();
      }
    });

    (function init() {
      const now = new Date();
      $("#txDate").value = now.toISOString().slice(0, 10);
      $("#txTime").value =
        String(now.getHours()).padStart(2, "0") +
        ":" +
        String(now.getMinutes()).padStart(2, "0");

      // Initialisation Flatpickr pour la date de constante
      flatpickr("#ctDate", {
        dateFormat: "Y-m-d",
        defaultDate: $("#txDate").value,
        locale: "fr",
        enableTime: false // Calendrier uniquement
      });

      // Initialisation Flatpickr pour l\'heure de constante
      flatpickr("#ctTime", {
        enableTime: true,
        noCalendar: true, // S√©lecteur d\'heure uniquement
        dateFormat: "H:i",
        defaultDate: $("#txTime").value,
        locale: "fr",
        time_24hr: true // Forcer le format 24h
      });

      $("#ctDate").value = $("#txDate").value;
      $("#ctTime").value = $("#txTime").value;

      // Initialiser les dates de filtrage (7 derniers jours par d√©faut)
      const today = new Date();
      const weekAgo = new Date(today);
      weekAgo.setDate(today.getDate() - 7);
      $("#ctDateFrom").value = weekAgo.toISOString().slice(0, 10);
      $("#ctDateTo").value = today.toISOString().slice(0, 10);
      $("#ctPeriod7").classList.add("active");

      patientInitial.textContent = currentPatient.trim()[0] || "?";

      renderAll();
    })();

    function setupNavigationDebug() {
      $$(".nav-item").forEach((btn) => {
        const originalClickListener = btn.onclick;
        btn.onclick = (event) => {
          console.log(`Debug Nav: Clic sur le bouton ${btn.dataset.screen}`);
          if (originalClickListener) {
            originalClickListener(event);
          }
          // Re-log the active screen state after toggle
          const screen = btn.dataset.screen;
          $$(".screen").forEach((s) => {
            console.log(`Debug Nav: √âcran ${s.id} est actif: ${s.classList.contains("active")}`);
          });
          console.log("Debug Nav: renderCt() sera appel√©e, v√©rifier la console pour son log.");
        };
      });
    }

  </script>
</body>
</html>